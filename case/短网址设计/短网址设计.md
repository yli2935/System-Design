# 短网址设计 (URL Shortener - Bit.ly/TinyURL)

## 一、问题理解

### 1.1 什么是短网址服务？

短网址服务（如 Bit.ly、TinyURL）是将长 URL 转换为短小、易管理的链接的服务，同时提供 URL 重定向功能和可选的分析功能。

**示例：**

- 长 URL: `https://www.systeminterview.com/q=chatsystem&c=loggedin&v=v3&l=long`
- 短 URL: `https://tinyurl.com/y7keocwj`

### 1.2 核心用例

1. **URL 缩短**：给定长 URL → 返回短 URL
2. **URL 重定向**：给定短 URL → 重定向到原始 URL
3. **高可用性、可扩展性和容错性**

### 1.3 CAP 选择：AP 系统还是 CP 系统？

根据 CAP 定理，分布式系统只能同时满足以下三个特性中的两个：

- **C (Consistency)** - 一致性：所有节点在同一时间看到相同的数据
- **A (Availability)** - 可用性：每个请求都能收到响应（成功或失败）
- **P (Partition Tolerance)** - 分区容错性：系统在网络分区时仍能继续运行

**短网址系统应该选择：AP 系统（可用性 + 分区容错性）**

#### 为什么选择 AP 而非 CP？

**1. 可用性比强一致性更重要**

- ✅ 用户点击短链接时，期望**立即**得到响应（< 100ms）
- ✅ 系统短暂不可用会导致糟糕的用户体验（404 错误）
- ⚠️ 短暂的数据不一致是**可以接受**的

**2. 最终一致性足够满足业务需求**

- 场景 1：用户创建短链接后立即分享
  - 即使新链接需要几秒钟才能在所有节点可用，用户通常不会立即点击
  - 通过 DNS 传播、消息发送等，通常有足够的时间差
- 场景 2：重复创建相同长 URL
  - 即使短暂出现两个不同的短链接映射到同一长 URL，也不会影响功能
  - 两个短链接都能正确重定向

**3. 读操作占主导（10:1 或更高）**

- 读操作可以从缓存和副本节点获取数据
- 即使副本有延迟，最终会同步
- 写操作相对较少，可以容忍短暂的复制延迟


#### 可接受的不一致场景

| 场景                     | 不一致表现                   | 影响程度 | 是否可接受 |
| ------------------------ | ---------------------------- | -------- | ---------- |
| 新建短链接后立即访问     | 部分节点返回 404（几秒内）   | 低       | ✅ 可接受  |
| 同一长 URL 被多次创建    | 生成多个短链接（都能正常用） | 低       | ✅ 可接受  |
| 更新短链接（如果支持）   | 部分用户看到旧目标 URL       | 中       | ✅ 可接受  |
| 读取点击统计（如果支持） | 统计数据延迟更新             | 低       | ✅ 可接受  |

#### 何时需要强一致性？（CP 系统特征）

如果短网址系统有以下特殊需求，可能需要考虑 CP 系统：

- ❌ **金融交易**：如果短链接用于支付跳转，需要强一致性
- ❌ **法律合规**：每次访问必须精确记录且不能丢失
- ❌ **一次性链接**：点击一次后立即失效（如密码重置链接）

但对于标准的短网址服务（如 Bit.ly、TinyURL），**AP 系统是最优选择**。

#### 总结

| 特性         | CP 系统            | AP 系统 ✅（推荐）   |
| ------------ | ------------------ | -------------------- |
| **一致性**   | 强一致性           | 最终一致性           |
| **可用性**   | 可能拒绝请求       | 始终响应             |
| **延迟**     | 较高（等待同步）   | 低（无需等待）       |
| **适用于**   | 金融、交易系统     | 社交媒体、内容分发   |
| **用户体验** | 可能出现服务不可用 | 响应快，偶尔数据稍旧 |

> 💡 **设计决策**：短网址系统优先保证**可用性和低延迟**，采用**最终一致性模型**，使其成为典型的 **AP 系统**。

---

## 二、需求分析

### 2.1 功能需求 (Functional Requirements)

**核心功能：**

1. ✅ 用户提交长 URL，获得短 URL
   - 可选：支持自定义别名（如 `www.short.ly/my-custom-alias`）
   - 可选：支持设置过期时间
2. ✅ 用户通过短 URL 访问原始 URL（重定向）

**不在范围内（Below the Line）：**

- ❌ 用户认证和账户管理
- ❌ 链接点击分析（点击次数、地理数据等）

### 2.2 非功能需求 (Non-Functional Requirements)

**核心要求：**

1. ✅ **唯一性**：每个短代码映射到唯一的长 URL
2. ✅ **低延迟**：重定向延迟 < 100ms
3. ✅ **高可用性**：99.99% 可用性（可用性 > 一致性）
4. ✅ **可扩展性**：支持 10 亿条短 URL，1 亿日活用户

**关键特征：**

- **读写比例严重不平衡**：读操作 >> 写操作（约 1000:1）
- 这将显著影响系统设计，特别是缓存策略、数据库选择和整体架构

### 2.3 容量估算 (Back-of-the-envelope Estimation)

**写操作量：**

- 每天生成：1 亿个 URL
- 每秒写操作：100,000,000 / 24 / 3600 ≈ **1,160 次/秒**

**读操作量：**

- 读写比例：10:1
- 每秒读操作：1,160 × 10 = **11,600 次/秒**

**存储需求：**

- 运行时长：10 年
- 总记录数：1 亿 × 365 × 10 = **3,650 亿条记录**
- 平均 URL 长度：100 字节
- 存储需求：3,650 亿 × 100 字节 = **365 TB**

**单条记录大小：**

- 短代码：~8 bytes
- 长 URL：~100 bytes
- 创建时间：~8 bytes
- 自定义别名：~100 bytes（可选）
- 过期时间：~8 bytes
- 其他元数据：~176 bytes
- **总计：~500 bytes/记录**

**10 亿条记录的存储：**

- 500 bytes × 1B = **500 GB**（单个现代 SSD 可以处理）

---

## 三、核心实体 (Core Entities)

```
1. 原始URL (Original URL)
   - 用户想要缩短的长URL

2. 短URL (Short URL)
   - 生成的短URL，用户可以分享

3. 用户 (User)
   - 创建短URL的用户
```

---

## 四、API 设计

### 4.1 缩短 URL

**端点：** `POST /api/v1/data/shorten` 或 `POST /urls`

**请求参数：**

```json
{
  "long_url": "https://www.example.com/some/very/long/url",
  "custom_alias": "optional_custom_alias", // 可选
  "expiration_date": "2026-12-31" // 可选
}
```

**响应：**

```json
{
  "short_url": "http://short.ly/abc123"
}
```

**说明：**

- 使用 POST 因为创建新资源（在数据库中创建映射）
- 返回完整的短 URL

### 4.2 URL 重定向

**端点：** `GET /{short_code}` 或 `GET /api/v1/{shortUrl}`

**请求：** `GET /abc123`

**响应：**

- HTTP 301/302 重定向到原始长 URL
- Location Header: 原始长 URL

**说明：**

- 使用 GET 因为读取现有资源
- 返回 HTTP 重定向状态码

---

## 五、高层设计 (High-Level Design)

### 5.1 URL 缩短流程

```
[Client]
   ↓ POST /urls (long_url)
[Load Balancer]
   ↓
[Write Service]
   ↓
   1. 检查 long_url 是否已存在
   2. 如果存在 → 返回现有 short_url
   3. 如果不存在：
      - 生成唯一ID
      - 将ID转换为短代码（Base62）
      - 存储映射到数据库
   ↓
[Database] <shortURL, longURL> 映射
   ↓
[Client] ← 返回 short_url
```

**流程说明：**

1. 用户提交长 URL
2. 系统检查长 URL 是否已存在于数据库
3. 如果存在，返回已有的短 URL
4. 如果不存在：
   - 唯一 ID 生成器生成全局唯一 ID
   - 使用 Base62 转换将 ID 转换为短代码
   - 创建数据库记录（ID, shortURL, longURL）
5. 返回短 URL 给客户端

### 5.2 URL 重定向流程

```
[Client]
   ↓ GET /{short_code}
[Load Balancer]
   ↓
[Read Service]
   ↓
   1. 检查缓存（Redis）
   2. 如果缓存命中 → 返回 long_url
   3. 如果缓存未命中：
      - 查询数据库
      - 更新缓存
   ↓
[Cache (Redis)] ← 缓存热门URL
   ↓
[Database]
   ↓
[Client] ← HTTP 301/302 重定向
```

**流程说明：**

1. 用户点击短 URL 链接
2. 负载均衡器转发请求到 Web 服务器
3. 检查缓存（Redis）
4. 如果命中缓存，直接返回长 URL
5. 如果未命中缓存，从数据库查询
6. 将结果写入缓存
7. 返回 HTTP 重定向给用户

### 5.3 301 vs 302 重定向

| 特性           | 301 Permanent Redirect                   | 302 Temporary Redirect          |
| -------------- | ---------------------------------------- | ------------------------------- |
| **含义**       | URL 永久移动到新地址                     | URL 临时移动到新地址            |
| **浏览器行为** | 浏览器缓存重定向，后续请求直接访问长 URL | 每次都向短 URL 服务发送请求     |
| **服务器负载** | ✅ 低（只有首次请求到达服务器）          | ❌ 高（每次请求都到达服务器）   |
| **点击追踪**   | ❌ 困难（后续请求不经过服务器）          | ✅ 容易（所有请求都经过服务器） |
| **适用场景**   | 优先考虑减少服务器负载                   | 优先考虑分析和点击追踪          |

**建议：**

- 如果重点是**减少服务器负载** → 使用 **301**
- 如果重点是**分析和追踪** → 使用 **302**

---

## 六、深入设计 (Deep Dive)

### 6.1 如何确保短 URL 的唯一性？

#### 约束条件：

1. 短代码必须唯一
2. 短代码尽可能短
3. 高效生成

#### 短代码长度计算

**字符集：** `[0-9, a-z, A-Z]` = 10 + 26 + 26 = **62 个字符**

**计算最小长度 n：** 满足 62^n ≥ 365 亿（3,650 亿条记录）

| 长度 n | 最大 URL 数 (62^n) | 是否足够？ |
| ------ | ------------------ | ---------- |
| 6      | ~568 亿            | ❌ 不足    |
| 7      | ~3.5 万亿          | ✅ 足够    |
| 8      | ~218 万亿          | ✅ 过剩    |

**结论：** 短代码长度为 **7 个字符**

---

#### 方案一：哈希函数 + 冲突解决 ❌

**原理：**
使用知名哈希函数（MD5、SHA-1、CRC32）对长 URL 进行哈希，取前 7 位。

**示例：** `https://en.wikipedia.org/wiki/Systems_design`

| 哈希算法 | 哈希结果长度 | 结果示例                         |
| -------- | ------------ | -------------------------------- |
| CRC32    | 8 字符       | c2c4200e                         |
| MD5      | 32 字符      | 5a62509a84df9ee03fe1230b9df8b84e |
| SHA-1    | 40 字符      | 0eeae7916c06853...               |

**问题：**

- ❌ 即使最短的 CRC32 也超过 7 字符
- ❌ 截取前 7 位会导致**哈希冲突**

**冲突解决：**

1. 如果发现冲突，追加预定义字符串到原 URL
2. 重新哈希
3. 递归直到无冲突

**优化：** 使用 **Bloom Filter** 减少数据库查询次数

**优缺点：**

- ✅ 固定短 URL 长度
- ✅ 不需要唯一 ID 生成器
- ❌ 可能出现冲突
- ❌ 每次请求需要查询数据库检查冲突（成本高）
- ❌ 无法预测下一个短 URL

---

#### 方案二：Base62 编码 + 唯一 ID ✅ (推荐)

**原理：**

1. 使用唯一 ID 生成器生成全局唯一 ID（数字）
2. 将 ID 转换为 Base62 编码

**Base62 编码映射：**

```
0-9  → 0-9
10-35 → a-z  (a=10, z=35)
36-61 → A-Z  (A=36, Z=61)
```

**转换示例：** 十进制 `11157` → Base62

```
11157 ÷ 62 = 179 ... 59  → 59 = 'X'
  179 ÷ 62 = 2   ... 55  → 55 = 'T'
    2 ÷ 62 = 0   ... 2   → 2  = '2'

结果：11157₁₀ = 2TX (Base62)
短URL：https://tinyurl.com/2TX
```

**计算过程：**

```
11157 = 2×62² + 55×62¹ + 59×62⁰
      = 2×3844 + 55×62 + 59×1
      = 7688 + 3410 + 59
      = 11157 ✓
```

**完整流程：**

```
[长URL输入]
   ↓
[检查数据库是否存在]
   ↓ 不存在
[唯一ID生成器] → 生成 ID: 2009215674938
   ↓
[Base62 转换] → 转换为: zn9edcu
   ↓
[存储到数据库]
   | ID            | Short URL | Long URL                              |
   |---------------|-----------|---------------------------------------|
   | 2009215674938 | zn9edcu   | https://en.wikipedia.org/wiki/Systems_design |
   ↓
[返回短URL: https://tinyurl.com/zn9edcu]
```

**唯一 ID 生成器：**

- 参考"第 7 章：分布式系统中的唯一 ID 生成器"
- 可选方案：
  - Snowflake 算法
  - UUID
  - 数据库自增 ID
  - Redis 原子计数器（推荐）

**优缺点：**

- ✅ **无冲突**（ID 唯一）
- ✅ 高效生成
- ✅ 易于实现
- ❌ 短 URL 长度不固定（随 ID 增长）
- ❌ 可预测下一个短 URL（潜在安全问题）
- ❌ 依赖唯一 ID 生成器

---

#### 两种方案对比

| 特性            | 哈希 + 冲突解决  | Base62 转换 ✅       |
| --------------- | ---------------- | -------------------- |
| **短 URL 长度** | 固定（7 字符）   | 不固定（随 ID 变化） |
| **唯一性**      | 可能冲突，需解决 | 无冲突（ID 唯一）    |
| **ID 生成器**   | 不需要           | 需要                 |
| **数据库查询**  | 需要（检查冲突） | 不需要               |
| **性能**        | 较低（冲突检查） | 高                   |
| **可预测性**    | 不可预测         | 可预测（安全风险）   |
| **实现复杂度**  | 较高             | 较低                 |

**推荐：** **Base62 转换** 是业界标准方案

---

### 6.2 如何确保重定向快速？

#### 问题分析

- 数据库中有数十亿条记录
- 全表扫描极慢
- 目标：< 100ms 延迟

---

#### 方案一：数据库索引 ✅

**原理：**
在 `short_url` 列上创建索引（B-Tree 或 Hash 索引）

**SQL 示例：**

```sql
CREATE INDEX idx_short_url ON url_mappings(short_url);

-- 查询
SELECT long_url FROM url_mappings WHERE short_url = 'abc123';
```

**效果：**

- ✅ 查询时间从 O(n) 降至 O(log n) 或 O(1)
- ✅ 适用于中等规模数据

**局限：**

- ⚠️ 仍然需要磁盘 I/O
- ⚠️ 高并发下数据库可能成为瓶颈

---

#### 方案二：内存缓存 (Redis) ✅✅ (推荐)

**原理：**
使用 Redis 缓存热门 `<short_url, long_url>` 映射

**架构：**

```
[请求] → [检查 Redis]
           ↓ 命中
         [返回 long_url]
           ↓ 未命中
         [查询数据库]
           ↓
         [写入 Redis]
           ↓
         [返回 long_url]
```

**缓存策略：**

1. **LRU（Least Recently Used）**：自动淘汰最少使用的条目
2. **TTL（Time To Live）**：设置过期时间（如 24 小时）
3. **缓存预热**：提前加载热门 URL

**效果：**

- ✅ 读取延迟 < 1ms（内存访问）
- ✅ 支持高并发（Redis 单实例可达 10 万 QPS）
- ✅ 减少数据库负载

**示例代码（伪代码）：**

```python
def get_long_url(short_code):
    # 1. 检查缓存
    long_url = redis.get(short_code)
    if long_url:
        return long_url

    # 2. 查询数据库
    long_url = database.query(f"SELECT long_url WHERE short_url = '{short_code}'")

    # 3. 写入缓存
    if long_url:
        redis.set(short_code, long_url, ttl=86400)  # 24小时

    return long_url
```

**缓存大小估算：**

- 假设缓存 1% 的热门 URL（帕累托法则）
- 10 亿条记录 × 1% = 1000 万条
- 1000 万条 × 500 bytes = **5 GB** （单个 Redis 实例可以处理）

---

#### 方案三：CDN 和边缘计算 ✅✅✅

**原理：**
在全球多个边缘节点缓存短 URL 映射，用户请求由最近的节点响应。

**优势：**

- ✅ 全球低延迟（< 50ms）
- ✅ 减少源站负载
- ✅ 提高可用性

**适用场景：**

- 全球用户分布
- 超高流量（数百万 QPS）

**实现：**

- 使用 CloudFlare、Akamai、AWS CloudFront 等 CDN 服务
- 配置缓存规则：`GET /{short_code}` → 缓存重定向响应

---

#### 三种方案对比

| 方案           | 延迟     | 吞吐量 | 成本 | 复杂度 | 适用场景 |
| -------------- | -------- | ------ | ---- | ------ | -------- |
| **数据库索引** | ~10-50ms | 中     | 低   | 低     | 中等规模 |
| **Redis 缓存** | ~1-5ms   | 高     | 中   | 中     | 高并发   |
| **CDN 边缘**   | ~10-30ms | 极高   | 高   | 高     | 全球分布 |

**推荐组合：** **数据库索引 + Redis 缓存 + CDN**（分层缓存策略）

---

### 6.3 如何扩展到 10 亿短 URL 和 1 亿 DAU？

#### 6.3.1 数据库扩展

**单库容量分析：**

- 10 亿条记录 × 500 bytes = **500 GB**
- 现代 SSD（1-2TB）完全可以处理
- **结论：** 单个 PostgreSQL/MySQL 实例足够

**写入吞吐量：**

- 10 万新 URL/天 ≈ **1 条/秒**
- PostgreSQL 可以轻松处理（单实例支持数千 TPS）

**数据库选择：**

- **PostgreSQL** / **MySQL**（推荐）：成熟、支持索引、事务
- **DynamoDB** / **Cassandra**：NoSQL，适合超大规模
- **选择建议：** 选择你最熟悉的技术（面试时说明理由）

**高可用性方案：**

1. **主从复制（Master-Slave Replication）：**

   ```
   [Primary DB] ← 写操作
       ↓ 复制
   [Replica 1]  ← 读操作
   [Replica 2]  ← 读操作
   ```

   - ✅ 读扩展（多个副本分担读负载）
   - ✅ 高可用（Primary 故障时切换到 Replica）
   - ⚠️ 复制延迟（最终一致性）

2. **数据库备份：**

   - 定期快照（如每小时）
   - 存储到 S3 / 对象存储
   - ✅ 灾难恢复

3. **分片（Sharding）：**（可选，当前规模不需要）
   - 按 `short_url` 哈希分片
   - 如：`shard_id = hash(short_url) % num_shards`

---

#### 6.3.2 应用层扩展：微服务架构

**问题：** 读操作 >> 写操作（10:1 或更高），单体服务无法独立扩展

**解决方案：** 分离读写服务

```
                [Load Balancer]
                 /            \
        [Write Service]    [Read Service]
        (少量实例)          (大量实例)
              |                  |
         [Database]         [Redis Cache]
                               |
                          [Database]
```

**架构说明：**

1. **Write Service（写服务）：**

   - 处理 `POST /urls` 请求
   - 生成短 URL
   - 写入数据库
   - 实例数少（如 3-5 个）

2. **Read Service（读服务）：**
   - 处理 `GET /{short_code}` 请求
   - 查询缓存/数据库
   - 返回重定向
   - 实例数多（如 50-100 个）

**优势：**

- ✅ 独立扩展（按需增减实例）
- ✅ 故障隔离（读服务故障不影响写服务）
- ✅ 技术栈优化（读服务可用不同语言/框架）

---

#### 6.3.3 水平扩展 (Horizontal Scaling)

**原理：**
增加服务实例数量来分担负载，而非提升单机性能（垂直扩展）。

**实现：**

```
[Load Balancer] (Nginx/ALB)
    ├─ [Read Service Instance 1]
    ├─ [Read Service Instance 2]
    ├─ [Read Service Instance 3]
    └─ ... (根据负载动态扩展)
```

**负载均衡算法：**

- Round Robin（轮询）
- Least Connections（最少连接）
- Random（随机）

**自动扩展：**

- 基于 CPU/内存使用率
- 基于 QPS（每秒查询数）
- Kubernetes HPA / AWS Auto Scaling

---

#### 6.3.4 唯一 ID 生成器的扩展挑战

**问题：**
水平扩展写服务后，多个实例需要共享计数器以保证 ID 全局唯一。

**解决方案一：集中式 Redis 计数器** ✅

```
[Write Service 1] ─┐
[Write Service 2] ─┼─→ [Redis Counter] ← 原子递增
[Write Service 3] ─┘      (INCR命令)
```

**流程：**

1. 写服务请求 Redis：`INCR url_counter`
2. Redis 原子递增并返回新值
3. 写服务使用该值生成短 URL

**优势：**

- ✅ Redis 单线程保证原子性
- ✅ 高性能（Redis 可达 10 万 QPS）
- ✅ 实现简单

**网络开销担忧？**

- 网络请求很快（< 1ms）
- 相比其他操作（数据库写入），开销可忽略

---

**解决方案二：计数器批量分配（Counter Batching）** ✅✅

**原理：**
每个写服务实例一次性申请一批 ID（如 1000 个），本地消费完再申请下一批。

**流程：**

```
[Write Service 1]
    1. 向Redis申请：INCRBY url_counter 1000
    2. Redis返回：1000（批次起始值）
    3. 本地使用：1000, 1001, 1002, ..., 1999
    4. 用完后再申请：INCRBY url_counter 1000
    5. Redis返回：2000
```

**优势：**

- ✅ 大幅减少 Redis 调用次数（1000 倍）
- ✅ 降低网络延迟
- ✅ 提高吞吐量

**权衡：**

- ⚠️ 服务崩溃会浪费未使用的 ID（可接受）
- ⚠️ ID 不再严格连续（无影响）

---

**解决方案三：Snowflake 算法**

**原理：**
64 位 ID = 时间戳(41 位) + 机器 ID(10 位) + 序列号(12 位)

**优势：**

- ✅ 无需中心化服务
- ✅ 趋势递增（有序）
- ✅ 高性能

**劣势：**

- ⚠️ 依赖机器时钟同步
- ⚠️ 实现复杂度较高

---

#### 6.3.5 Redis 高可用性

**方案：**

1. **Redis Sentinel（哨兵模式）：**

   ```
   [Sentinel 1]
   [Sentinel 2]  → 监控 → [Redis Master]
   [Sentinel 3]              ↓ 复制
                         [Redis Slave]
   ```

   - 自动故障转移
   - 主节点故障时自动提升从节点

2. **Redis Cluster（集群模式）：**

   - 数据分片
   - 高可用 + 高性能

3. **Redis Enterprise：**

   - 托管服务
   - 跨区域复制
   - 自动备份

4. **持久化：**
   - **RDB**：定期快照（如每 5 分钟）
   - **AOF**：追加操作日志（更高持久性）
   - 定期备份计数器值到持久化存储

---

#### 6.3.6 最终架构图

```
                     [CDN / Edge Nodes]
                            ↓
                    [Load Balancer]
                   /                \
        [Write Services]      [Read Services]
           (3 实例)             (50 实例)
              ↓                      ↓
         [Redis Counter]      [Redis Cache Cluster]
              ↓                      ↓
        [Primary DB] ←─────────────┘
              ↓ 复制
        [Replica DB 1]
        [Replica DB 2]
```

**流程说明：**

**写流程：**

1. 用户 → CDN/LB → Write Service
2. Write Service → Redis Counter（获取唯一 ID）
3. Write Service → Base62 转换 → 生成短 URL
4. Write Service → Database（写入映射）
5. 返回短 URL

**读流程：**

1. 用户 → CDN（缓存命中 → 直接返回）
2. 用户 → LB → Read Service
3. Read Service → Redis Cache（缓存命中 → 返回）
4. Read Service → Database（缓存未命中 → 查询）
5. Read Service → Redis Cache（更新缓存）
6. 返回 HTTP 重定向

---

## 七、数据模型设计

### 7.1 数据库表结构

**表名：** `url_mappings`

| 字段名         | 类型        | 说明                    | 索引         |
| -------------- | ----------- | ----------------------- | ------------ |
| `id`           | BIGINT      | 唯一 ID（主键）         | PRIMARY KEY  |
| `short_url`    | VARCHAR(10) | 短代码（如 "zn9edcu"）  | UNIQUE INDEX |
| `long_url`     | TEXT        | 原始长 URL              | -            |
| `created_at`   | TIMESTAMP   | 创建时间                | INDEX        |
| `expires_at`   | TIMESTAMP   | 过期时间（可为 NULL）   | INDEX        |
| `custom_alias` | VARCHAR(50) | 自定义别名（可为 NULL） | UNIQUE INDEX |
| `user_id`      | BIGINT      | 创建者 ID（可为 NULL）  | INDEX        |

**SQL 示例：**

```sql
CREATE TABLE url_mappings (
    id BIGINT PRIMARY KEY,
    short_url VARCHAR(10) UNIQUE NOT NULL,
    long_url TEXT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    expires_at TIMESTAMP NULL,
    custom_alias VARCHAR(50) UNIQUE NULL,
    user_id BIGINT NULL,
    INDEX idx_short_url (short_url),
    INDEX idx_created_at (created_at),
    INDEX idx_expires_at (expires_at)
);
```

### 7.2 Redis 数据结构

**1. URL 映射缓存：**

```redis
Key: short_url:{short_code}
Value: {long_url}
TTL: 86400 (24小时)

示例：
SET short_url:abc123 "https://example.com/long/url" EX 86400
GET short_url:abc123
```

**2. 计数器：**

```redis
Key: url_counter
Value: {current_id}

示例：
INCR url_counter          # 返回 1
INCRBY url_counter 1000   # 批量分配，返回 1001
```

---

## 八、附加考虑点

### 8.1 速率限制（Rate Limiting）

**问题：** 恶意用户大量创建短 URL

**解决方案：**

- 基于 IP 地址限流（如：100 次/小时）
- 基于 User ID 限流（需要认证）
- 使用 Token Bucket 或 Sliding Window 算法
- 参考"第 4 章：设计速率限制器"

**实现：**

```python
# 使用 Redis 实现滑动窗口
def is_rate_limited(ip_address):
    key = f"rate_limit:{ip_address}"
    current_time = int(time.time())
    window_start = current_time - 3600  # 1小时窗口

    # 清除过期记录
    redis.zremrangebyscore(key, 0, window_start)

    # 检查当前计数
    count = redis.zcard(key)
    if count >= 100:
        return True

    # 记录本次请求
    redis.zadd(key, {current_time: current_time})
    redis.expire(key, 3600)
    return False
```

### 8.2 安全性考虑

**1. 恶意 URL 过滤：**

- 黑名单检查（恶意域名）
- 与第三方 API 集成（如 Google Safe Browsing）

**2. 防止枚举攻击：**

- 使用随机化的 ID（而非递增）
- 加盐哈希

**3. HTTPS：**

- 强制使用 HTTPS
- 防止中间人攻击

### 8.3 监控和分析（可选）

**如果需要实现：**

1. **点击统计：**

   - 每次重定向时，异步写入点击事件到消息队列（Kafka）
   - 后台服务消费队列，聚合数据

2. **实时仪表板：**

   - 使用 Flink / Spark Streaming 实时计算
   - 存储到时序数据库（InfluxDB / TimescaleDB）

3. **指标：**
   - 点击次数
   - 地理位置分布
   - 设备类型（移动/桌面）
   - Referrer（流量来源）

**架构：**

```
[Read Service]
    ↓ (异步)
[Kafka] → [Flink] → [TimescaleDB] → [Grafana 仪表板]
```

### 8.4 过期 URL 清理

**策略：**

1. **被动删除（Lazy Deletion）：**

   - 访问时检查 `expires_at`
   - 如果过期，返回 404，异步删除记录

2. **主动删除（Active Deletion）：**

   - 定时任务（Cron Job）每天清理过期记录
   - SQL：`DELETE FROM url_mappings WHERE expires_at < NOW()`

3. **TTL 索引（MongoDB / DynamoDB）：**
   - 数据库自动删除过期数据

---

## 九、面试要点总结

### 9.1 核心知识点

✅ **必须掌握：**

1. Base62 编码原理和实现
2. 读写分离架构
3. 缓存策略（Redis）
4. 唯一 ID 生成（计数器、Snowflake）
5. 301 vs 302 重定向的权衡
6. 容量估算和存储计算
7. 数据库索引优化

### 9.2 常见面试问题

**Q1: 如何处理同一长 URL 多次提交？**

- A: 查询数据库，如果已存在则返回现有短 URL（幂等性）

**Q2: 如何保证短 URL 永不重复？**

- A: 使用全局唯一 ID 生成器 + Base62 编码（无哈希冲突）

**Q3: 如果 Redis 宕机怎么办？**

- A: Redis Sentinel/Cluster 高可用；即使宕机，降级到数据库查询（性能下降但服务可用）

**Q4: 如何支持自定义短 URL？**

- A: 检查自定义别名是否已被占用（数据库唯一索引），如果可用则存储

**Q5: 如何处理热门 URL（如明星发的链接）？**

- A:
  - Redis 缓存（LRU 淘汰）
  - CDN 缓存
  - 读服务水平扩展

**Q6: 估算系统的 QPS 上限？**

- A:
  - 单个读服务实例：1000 QPS
  - 50 个实例：50,000 QPS
  - Redis：100,000 QPS
  - 瓶颈：数据库（可通过缓存命中率缓解）

### 9.3 设计权衡（Trade-offs）

| 决策点           | 选项 A            | 选项 B            | 推荐               |
| ---------------- | ----------------- | ----------------- | ------------------ |
| **短 URL 生成**  | 哈希+冲突解决     | Base62 编码       | Base62 ✅          |
| **重定向状态码** | 301（减少负载）   | 302（追踪点击）   | 取决于需求         |
| **数据库**       | SQL（PostgreSQL） | NoSQL（DynamoDB） | SQL ✅             |
| **缓存**         | Redis             | Memcached         | Redis ✅           |
| **ID 生成**      | 集中式计数器      | Snowflake         | 计数器+批量分配 ✅ |

---

## 十、参考资料

### 10.1 相关章节

- 第 4 章：设计速率限制器
- 第 7 章：分布式系统中的唯一 ID 生成器
- 第 1 章：可用性、一致性和可靠性

### 10.2 扩展阅读

- [RESTful API 教程](https://www.restapitutorial.com/index.html)
- [Bloom Filter - Wikipedia](https://en.wikipedia.org/wiki/Bloom_filter)
- [Base62 编码原理](https://en.wikipedia.org/wiki/Base62)
- [Redis 官方文档](https://redis.io/documentation)
- [Hello Interview - Design Bit.ly](https://www.hellointerview.com/learn/system-design/problem-breakdowns/bitly)

---

## 十一、练习建议

### 11.1 代码实现练习

1. 实现 Base62 编码/解码函数
2. 实现 Redis 缓存查询逻辑
3. 实现简单的速率限制器

### 11.2 架构设计练习

1. 画出完整的系统架构图
2. 设计数据库表结构
3. 编写 API 规范文档

### 11.3 问题扩展

1. 如何支持短 URL 编辑和删除？
2. 如何实现短 URL 预览功能（显示目标 URL 信息）？
3. 如何设计短 URL 的访问控制（私密链接）？

---

**恭喜！你已经掌握了短网址系统设计的核心知识点。**

> 💡 **面试技巧：**
>
> - 先讲清楚功能和非功能需求
> - 从简单设计开始，逐步深入
> - 主动讨论权衡（trade-offs）
> - 画图！（架构图、流程图、数据流图）
> - 量化分析（容量估算、QPS 计算）
> - 询问面试官的反馈和建议

**祝你面试成功！🚀**
